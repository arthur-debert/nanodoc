package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestSaveToBundleFlag(t *testing.T) {
	tests := []struct {
		name           string
		args           []string
		expectedError  bool
		checkFile      bool
		expectedInFile []string
	}{
		{
			name: "save simple bundle",
			args: []string{"README.md", "--save-to-bundle", "test.bundle.txt"},
			checkFile: true,
			expectedInFile: []string{
				"# Bundle generated by nanodoc",
				"# --- Options ---",
				"--theme=classic",
				"--header-format=nice",
				"--file-numbering=numerical",
				"# --- Content ---",
				"README.md",
			},
		},
		{
			name: "save bundle with options",
			args: []string{"README.md", "--toc", "--linenum", "file", "--theme", "classic-dark", "--save-to-bundle", "test-opts.bundle.txt"},
			checkFile: true,
			expectedInFile: []string{
				"--toc",
				"--linenum=file",
				"--theme=classic-dark",
				"README.md",
			},
		},
		{
			name: "save bundle with multiple files",
			args: []string{"README.md", "LICENSE", "--save-to-bundle", "multi.bundle.txt"},
			checkFile: true,
			expectedInFile: []string{
				"README.md",
				"LICENSE",
			},
		},
		{
			name: "save bundle with patterns",
			args: []string{"*.md", "--include", "**/*.go", "--exclude", "**/test/*", "--save-to-bundle", "patterns.bundle.txt"},
			checkFile: true,
			expectedInFile: []string{
				"--include=\"**/*.go\"",
				"--exclude=\"**/test/*\"",
				"*.md",
			},
		},
		{
			name: "save bundle with additional extensions",
			args: []string{"src/", "--ext", "go", "--ext", "rs", "--save-to-bundle", "ext.bundle.txt"},
			checkFile: true,
			expectedInFile: []string{
				"--ext=go",
				"--ext=rs",
				"src/",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a temporary directory for test files
			tempDir := t.TempDir()
			oldDir, _ := os.Getwd()
			defer func() { _ = os.Chdir(oldDir) }()
			if err := os.Chdir(tempDir); err != nil {
				t.Fatalf("Failed to change directory: %v", err)
			}

			// Create test files
			if err := os.WriteFile("README.md", []byte("# Test\nContent"), 0644); err != nil {
				t.Fatalf("Failed to create README.md: %v", err)
			}
			if err := os.WriteFile("LICENSE", []byte("MIT License"), 0644); err != nil {
				t.Fatalf("Failed to create LICENSE: %v", err)
			}
			if err := os.Mkdir("src", 0755); err != nil {
				t.Fatalf("Failed to create src directory: %v", err)
			}
			if err := os.WriteFile("src/main.go", []byte("package main"), 0644); err != nil {
				t.Fatalf("Failed to create main.go: %v", err)
			}

			// Update args to use temp file paths
			for i, arg := range tt.args {
				if strings.HasSuffix(arg, ".bundle.txt") {
					tt.args[i] = filepath.Join(tempDir, arg)
				}
			}

			// Run the command
			output, err := executeCommand(tt.args...)

			// Check error
			if tt.expectedError && err == nil {
				t.Errorf("expected error but got none")
			}
			if !tt.expectedError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}

			// Check output contains success message
			if !tt.expectedError && !strings.Contains(output, "Bundle saved to") {
				t.Errorf("output missing success message: %s", output)
			}

			// Check file contents if needed
			if tt.checkFile && !tt.expectedError {
				bundlePath := ""
				for i, arg := range tt.args {
					if arg == "--save-to-bundle" && i+1 < len(tt.args) {
						bundlePath = tt.args[i+1]
						break
					}
				}

				content, err := os.ReadFile(bundlePath)
				if err != nil {
					t.Errorf("failed to read bundle file: %v", err)
				}

				contentStr := string(content)
				for _, expected := range tt.expectedInFile {
					if !strings.Contains(contentStr, expected) {
						t.Errorf("bundle file missing expected content: %q\n\nGot:\n%s", expected, contentStr)
					}
				}
			}
		})
	}
}

func TestSaveToBundleOverwriteError(t *testing.T) {
	tempDir := t.TempDir()
	bundlePath := filepath.Join(tempDir, "existing.bundle.txt")
	
	// Create an existing bundle file
	if err := os.WriteFile(bundlePath, []byte("existing content"), 0644); err != nil {
		t.Fatalf("Failed to create existing bundle: %v", err)
	}
	
	oldDir, _ := os.Getwd()
	defer func() { _ = os.Chdir(oldDir) }()
	if err := os.Chdir(tempDir); err != nil {
		t.Fatalf("Failed to change directory: %v", err)
	}
	
	// Create a test file
	if err := os.WriteFile("test.txt", []byte("test content"), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
	
	// Try to save over existing file
	_, err := executeCommand("test.txt", "--save-to-bundle", bundlePath)
	
	if err == nil {
		t.Error("expected error for existing file, but got none")
	}
	
	if !strings.Contains(err.Error(), "already exists") {
		t.Errorf("unexpected error message: %v", err)
	}
	
	// Verify original file was not modified
	content, _ := os.ReadFile(bundlePath)
	if string(content) != "existing content" {
		t.Error("existing file was modified")
	}
}

func TestSaveToBundleWithAllFlags(t *testing.T) {
	tempDir := t.TempDir()
	bundlePath := filepath.Join(tempDir, "all-flags.bundle.txt")

	oldDir, _ := os.Getwd()
	defer func() { _ = os.Chdir(oldDir) }()
	if err := os.Chdir(tempDir); err != nil {
		t.Fatalf("Failed to change directory: %v", err)
	}

	// Create test file
	if err := os.WriteFile("test.txt", []byte("test content"), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Test with all possible flags
	args := []string{
		"test.txt",
		"--toc",
		"--linenum", "global",
		"--theme", "classic-dark",
		"--filenames=false",
		"--header-format", "path",
		"--file-numbering", "roman",
		"--ext", "go",
		"--ext", "rs",
		"--include", "**/*.txt",
		"--exclude", "**/temp/*",
	}
	
	// Run the command to save the bundle
	saveArgs := append(args, "--save-to-bundle", bundlePath)
	originalOutput, err := executeCommand(saveArgs...)
	if err != nil {
		t.Fatalf("unexpected error when saving bundle: %v", err)
	}

	// Now run nanodoc with the generated bundle
	bundleOutput, err := executeCommand(bundlePath)
	if err != nil {
		t.Fatalf("unexpected error when running from bundle: %v", err)
	}

	// The output should be the same, except for the "Bundle saved" message
	originalOutput = strings.Split(originalOutput, "\n\nBundle saved to")[0]
	if originalOutput != bundleOutput {
		t.Errorf("output from bundle does not match original output.\nOriginal:\n%s\n\nBundle:\n%s", originalOutput, bundleOutput)
	}
}
